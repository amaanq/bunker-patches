From a31a730898c312875d59353f985d3138d4a13045 Mon Sep 17 00:00:00 2001
From: Alexandre Frade <kernel@xanmod.org>
Date: Sun, 8 Feb 2026 00:53:56 -0500
Subject: [PATCH 50/180] binder: turn into loadable module

Make the Android binder driver buildable as a loadable kernel module
instead of only built-in. Exports necessary symbols from core kernel
subsystems (mm, ipc, security, sched) to support this.

Enables Waydroid/Anbox support without compiling binder into the
kernel permanently.
---
 drivers/android/Kconfig           |  6 +++---
 drivers/android/Makefile          |  9 +++++----
 drivers/android/binder.c          | 15 ++++++++++++++-
 drivers/android/binder_alloc.h    |  1 +
 drivers/android/binder_internal.h |  5 +++--
 drivers/android/binderfs.c        |  6 +++---
 include/linux/ipc_namespace.h     |  3 +++
 ipc/namespace.c                   | 17 +++++++++++++++++
 kernel/sched/syscalls.c           |  1 +
 kernel/task_work.c                |  1 +
 mm/list_lru.c                     |  2 ++
 mm/memory.c                       |  1 +
 mm/mmap_lock.c                    |  1 +
 mm/vmalloc.c                      |  1 +
 security/security.c               |  4 ++++
 15 files changed, 60 insertions(+), 13 deletions(-)

diff --git a/drivers/android/Kconfig b/drivers/android/Kconfig
index e2e402c9d175..20c985de667e 100644
--- a/drivers/android/Kconfig
+++ b/drivers/android/Kconfig
@@ -1,10 +1,10 @@
 # SPDX-License-Identifier: GPL-2.0
 menu "Android"
 
 config ANDROID_BINDER_IPC
-	bool "Android Binder IPC Driver"
+	tristate "Android Binder IPC Driver"
 	depends on MMU
 	depends on NET
 	default n
 	help
 	  Binder is used in Android for both communication between processes,
@@ -26,12 +26,12 @@ config ANDROID_BINDER_IPC_RUST
 	  This means one Android process can call a method/routine in another
 	  Android process, using Binder to identify, invoke and pass arguments
 	  between said processes.
 
 config ANDROID_BINDERFS
-	bool "Android Binderfs filesystem"
-	depends on ANDROID_BINDER_IPC
+	tristate "Android Binderfs filesystem"
+	depends on (ANDROID_BINDER_IPC=y) || (ANDROID_BINDER_IPC=m && m)
 	default n
 	help
 	  Binderfs is a pseudo-filesystem for the Android Binder IPC driver
 	  which can be mounted per-ipc namespace allowing to run multiple
 	  instances of Android.
diff --git a/drivers/android/Makefile b/drivers/android/Makefile
index e0c650d3898e..81ac0681fa1b 100644
--- a/drivers/android/Makefile
+++ b/drivers/android/Makefile
@@ -1,7 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0-only
 ccflags-y += -I$(src)			# needed for trace events
 
-obj-$(CONFIG_ANDROID_BINDERFS)		+= binderfs.o
-obj-$(CONFIG_ANDROID_BINDER_IPC)	+= binder.o binder_alloc.o binder_netlink.o
-obj-$(CONFIG_ANDROID_BINDER_ALLOC_KUNIT_TEST)	+= tests/
-obj-$(CONFIG_ANDROID_BINDER_IPC_RUST)	+= binder/
+binder_linux-y := binder.o binder_alloc.o binder_netlink.o
+obj-$(CONFIG_ANDROID_BINDER_IPC) += binder_linux.o
+binder_linux-$(CONFIG_ANDROID_BINDERFS) += binderfs.o
+binder_linux-$(CONFIG_ANDROID_BINDER_ALLOC_KUNIT_TEST) += binder_alloc_selftest.o
+binder_linux-$(CONFIG_ANDROID_BINDER_IPC_RUST)   += binder/
diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index b356c9b88254..8e02e223425e 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -7165,9 +7165,22 @@ static int __init binder_init(void)
 	binder_alloc_shrinker_exit();
 
 	return ret;
 }
 
-device_initcall(binder_init);
+module_init(binder_init);
+/*
+ * binder will have no exit function since binderfs instances can be mounted
+ * multiple times and also in user namespaces finding and destroying them all
+ * is not feasible without introducing insane locking. Just ignoring existing
+ * instances on module unload also wouldn't work since we would loose track of
+ * what major numer was dynamically allocated and also what minor numbers are
+ * already given out. So this would get us into all kinds of issues with device
+ * number reuse. So simply don't allow unloading unless we are forced to do so.
+ */
+
+MODULE_AUTHOR("Google, Inc.");
+MODULE_DESCRIPTION("Driver for Android binder device");
+MODULE_LICENSE("GPL v2");
 
 #define CREATE_TRACE_POINTS
 #include "binder_trace.h"
diff --git a/drivers/android/binder_alloc.h b/drivers/android/binder_alloc.h
index d6f1f6f2d00e..7edae3eb50f5 100644
--- a/drivers/android/binder_alloc.h
+++ b/drivers/android/binder_alloc.h
@@ -4,10 +4,11 @@
  */
 
 #ifndef _LINUX_BINDER_ALLOC_H
 #define _LINUX_BINDER_ALLOC_H
 
+#include <linux/kconfig.h>
 #include <linux/rbtree.h>
 #include <linux/list.h>
 #include <linux/mm.h>
 #include <linux/rtmutex.h>
 #include <linux/vmalloc.h>
diff --git a/drivers/android/binder_internal.h b/drivers/android/binder_internal.h
index 342574bfd28a..a723f845bd6a 100644
--- a/drivers/android/binder_internal.h
+++ b/drivers/android/binder_internal.h
@@ -2,10 +2,11 @@
 
 #ifndef _LINUX_BINDER_INTERNAL_H
 #define _LINUX_BINDER_INTERNAL_H
 
 #include <linux/fs.h>
+#include <linux/kconfig.h>
 #include <linux/list.h>
 #include <linux/miscdevice.h>
 #include <linux/mutex.h>
 #include <linux/refcount.h>
 #include <linux/stddef.h>
@@ -74,11 +75,11 @@ struct binderfs_info {
 
 extern const struct file_operations binder_fops;
 
 extern char *binder_devices_param;
 
-#ifdef CONFIG_ANDROID_BINDERFS
+#if IS_ENABLED(CONFIG_ANDROID_BINDERFS)
 extern bool is_binderfs_device(const struct inode *inode);
 extern struct dentry *binderfs_create_file(struct dentry *dir, const char *name,
 					   const struct file_operations *fops,
 					   void *data);
 #else
@@ -93,11 +94,11 @@ static inline struct dentry *binderfs_create_file(struct dentry *dir,
 {
 	return NULL;
 }
 #endif
 
-#ifdef CONFIG_ANDROID_BINDERFS
+#if IS_ENABLED(CONFIG_ANDROID_BINDERFS)
 extern int __init init_binderfs(void);
 #else
 static inline int __init init_binderfs(void)
 {
 	return 0;
diff --git a/drivers/android/binderfs.c b/drivers/android/binderfs.c
index 9f8a18c88d66..2df67f49492f 100644
--- a/drivers/android/binderfs.c
+++ b/drivers/android/binderfs.c
@@ -121,11 +121,11 @@ static int binderfs_binder_device_create(struct inode *ref_inode,
 	char *name = NULL;
 	struct inode *inode = NULL;
 	struct super_block *sb = ref_inode->i_sb;
 	struct binderfs_info *info = sb->s_fs_info;
 #if defined(CONFIG_IPC_NS)
-	bool use_reserve = (info->ipc_ns == &init_ipc_ns);
+	bool use_reserve = (info->ipc_ns == show_init_ipc_ns());
 #else
 	bool use_reserve = true;
 #endif
 
 	/* Reserve new minor number for the new device. */
@@ -389,11 +389,11 @@ static int binderfs_binder_ctl_create(struct super_block *sb)
 	struct binder_device *device;
 	struct inode *inode = NULL;
 	struct dentry *root = sb->s_root;
 	struct binderfs_info *info = sb->s_fs_info;
 #if defined(CONFIG_IPC_NS)
-	bool use_reserve = (info->ipc_ns == &init_ipc_ns);
+	bool use_reserve = (info->ipc_ns == show_init_ipc_ns());
 #else
 	bool use_reserve = true;
 #endif
 
 	device = kzalloc(sizeof(*device), GFP_KERNEL);
@@ -641,11 +641,11 @@ static int binderfs_fill_super(struct super_block *sb, struct fs_context *fc)
 	sb->s_fs_info = kzalloc(sizeof(struct binderfs_info), GFP_KERNEL);
 	if (!sb->s_fs_info)
 		return -ENOMEM;
 	info = sb->s_fs_info;
 
-	info->ipc_ns = get_ipc_ns(current->nsproxy->ipc_ns);
+	info->ipc_ns = get_ipc_ns_exported(current->nsproxy->ipc_ns);
 
 	info->root_gid = make_kgid(sb->s_user_ns, 0);
 	if (!gid_valid(info->root_gid))
 		info->root_gid = GLOBAL_ROOT_GID;
 	info->root_uid = make_kuid(sb->s_user_ns, 0);
diff --git a/include/linux/ipc_namespace.h b/include/linux/ipc_namespace.h
index 12faca29bbb9..5bf174df249e 100644
--- a/include/linux/ipc_namespace.h
+++ b/include/linux/ipc_namespace.h
@@ -126,10 +126,13 @@ extern int mq_init_ns(struct ipc_namespace *ns);
 #define HARD_MSGSIZEMAX	    (16*1024*1024)
 #else
 static inline int mq_init_ns(struct ipc_namespace *ns) { return 0; }
 #endif
 
+extern struct ipc_namespace *get_ipc_ns_exported(struct ipc_namespace *ns);
+extern struct ipc_namespace *show_init_ipc_ns(void);
+
 #if defined(CONFIG_IPC_NS)
 static inline struct ipc_namespace *to_ipc_ns(struct ns_common *ns)
 {
 	return container_of(ns, struct ipc_namespace, ns);
 }
diff --git a/ipc/namespace.c b/ipc/namespace.c
index 535f16ea40e1..c12da4ff9a09 100644
--- a/ipc/namespace.c
+++ b/ipc/namespace.c
@@ -208,10 +208,27 @@ void put_ipc_ns(struct ipc_namespace *ns)
 		ns_tree_remove(ns);
 		if (llist_add(&ns->mnt_llist, &free_ipc_list))
 			schedule_work(&free_ipc_work);
 	}
 }
+EXPORT_SYMBOL(put_ipc_ns);
+
+struct ipc_namespace *get_ipc_ns_exported(struct ipc_namespace *ns)
+{
+	return get_ipc_ns(ns);
+}
+EXPORT_SYMBOL(get_ipc_ns_exported);
+
+struct ipc_namespace *show_init_ipc_ns(void)
+{
+#if defined(CONFIG_IPC_NS)
+	return &init_ipc_ns;
+#else
+	return NULL;
+#endif
+}
+EXPORT_SYMBOL(show_init_ipc_ns);
 
 static struct ns_common *ipcns_get(struct task_struct *task)
 {
 	struct ipc_namespace *ns = NULL;
 	struct nsproxy *nsproxy;
diff --git a/kernel/sched/syscalls.c b/kernel/sched/syscalls.c
index c2f60d9460f4..08adb62ac3d7 100644
--- a/kernel/sched/syscalls.c
+++ b/kernel/sched/syscalls.c
@@ -117,10 +117,11 @@ static bool is_nice_reduction(const struct task_struct *p, const int nice)
  */
 int can_nice(const struct task_struct *p, const int nice)
 {
 	return is_nice_reduction(p, nice) || capable(CAP_SYS_NICE);
 }
+EXPORT_SYMBOL(can_nice);
 
 #ifdef __ARCH_WANT_SYS_NICE
 
 /*
  * sys_nice - change the priority of the current process.
diff --git a/kernel/task_work.c b/kernel/task_work.c
index 0f7519f8e7c9..08eb29abaea6 100644
--- a/kernel/task_work.c
+++ b/kernel/task_work.c
@@ -100,10 +100,11 @@ int task_work_add(struct task_struct *task, struct callback_head *work,
 		break;
 	}
 
 	return 0;
 }
+EXPORT_SYMBOL(task_work_add);
 
 /**
  * task_work_cancel_match - cancel a pending work added by task_work_add()
  * @task: the task which should execute the work
  * @match: match function to call
diff --git a/mm/list_lru.c b/mm/list_lru.c
index ec48b5dadf51..bf95d73c9815 100644
--- a/mm/list_lru.c
+++ b/mm/list_lru.c
@@ -177,10 +177,11 @@ bool list_lru_add(struct list_lru *lru, struct list_head *item, int nid,
 		return true;
 	}
 	unlock_list_lru(l, false);
 	return false;
 }
+EXPORT_SYMBOL_GPL(list_lru_add);
 
 bool list_lru_add_obj(struct list_lru *lru, struct list_head *item)
 {
 	bool ret;
 	int nid = page_to_nid(virt_to_page(item));
@@ -214,10 +215,11 @@ bool list_lru_del(struct list_lru *lru, struct list_head *item, int nid,
 		return true;
 	}
 	unlock_list_lru(l, false);
 	return false;
 }
+EXPORT_SYMBOL_GPL(list_lru_del);
 
 bool list_lru_del_obj(struct list_lru *lru, struct list_head *item)
 {
 	bool ret;
 	int nid = page_to_nid(virt_to_page(item));
diff --git a/mm/memory.c b/mm/memory.c
index da360a6eb8a4..64083ace239a 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2166,10 +2166,11 @@ void zap_page_range_single(struct vm_area_struct *vma, unsigned long address,
 
 	tlb_gather_mmu(&tlb, vma->vm_mm);
 	zap_page_range_single_batched(&tlb, vma, address, size, details);
 	tlb_finish_mmu(&tlb);
 }
+EXPORT_SYMBOL(zap_page_range_single);
 
 /**
  * zap_vma_ptes - remove ptes mapping the vma
  * @vma: vm_area_struct holding ptes to be zapped
  * @address: starting address of pages to zap
diff --git a/mm/mmap_lock.c b/mm/mmap_lock.c
index 7421b7ea8001..1933e8bafab4 100644
--- a/mm/mmap_lock.c
+++ b/mm/mmap_lock.c
@@ -287,10 +287,11 @@ struct vm_area_struct *lock_vma_under_rcu(struct mm_struct *mm,
 
 inval:
 	count_vm_vma_lock_event(VMA_LOCK_ABORT);
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(lock_vma_under_rcu);
 
 static struct vm_area_struct *lock_next_vma_under_mmap_lock(struct mm_struct *mm,
 							    struct vma_iterator *vmi,
 							    unsigned long from_addr)
 {
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index e286c2d2068c..e30857a42821 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -3261,10 +3261,11 @@ struct vm_struct *get_vm_area(unsigned long size, unsigned long flags)
 	return __get_vm_area_node(size, 1, PAGE_SHIFT, flags,
 				  VMALLOC_START, VMALLOC_END,
 				  NUMA_NO_NODE, GFP_KERNEL,
 				  __builtin_return_address(0));
 }
+EXPORT_SYMBOL(get_vm_area);
 
 struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,
 				const void *caller)
 {
 	return __get_vm_area_node(size, 1, PAGE_SHIFT, flags,
diff --git a/security/security.c b/security/security.c
index 31a688650601..6fd9dc64a611 100644
--- a/security/security.c
+++ b/security/security.c
@@ -486,10 +486,11 @@ OUT:									\
  */
 int security_binder_set_context_mgr(const struct cred *mgr)
 {
 	return call_int_hook(binder_set_context_mgr, mgr);
 }
+EXPORT_SYMBOL(security_binder_set_context_mgr);
 
 /**
  * security_binder_transaction() - Check if a binder transaction is allowed
  * @from: sending process
  * @to: receiving process
@@ -501,10 +502,11 @@ int security_binder_set_context_mgr(const struct cred *mgr)
 int security_binder_transaction(const struct cred *from,
 				const struct cred *to)
 {
 	return call_int_hook(binder_transaction, from, to);
 }
+EXPORT_SYMBOL(security_binder_transaction);
 
 /**
  * security_binder_transfer_binder() - Check if a binder transfer is allowed
  * @from: sending process
  * @to: receiving process
@@ -516,10 +518,11 @@ int security_binder_transaction(const struct cred *from,
 int security_binder_transfer_binder(const struct cred *from,
 				    const struct cred *to)
 {
 	return call_int_hook(binder_transfer_binder, from, to);
 }
+EXPORT_SYMBOL(security_binder_transfer_binder);
 
 /**
  * security_binder_transfer_file() - Check if a binder file xfer is allowed
  * @from: sending process
  * @to: receiving process
@@ -532,10 +535,11 @@ int security_binder_transfer_binder(const struct cred *from,
 int security_binder_transfer_file(const struct cred *from,
 				  const struct cred *to, const struct file *file)
 {
 	return call_int_hook(binder_transfer_file, from, to, file);
 }
+EXPORT_SYMBOL(security_binder_transfer_file);
 
 /**
  * security_ptrace_access_check() - Check if tracing is allowed
  * @child: target process
  * @mode: PTRACE_MODE flags
-- 
2.52.0

