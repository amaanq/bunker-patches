From 156e1302df00a612a15e8e70ed70be2697480dc4 Mon Sep 17 00:00:00 2001
From: Thibaut Sautereau <thibaut.sautereau@ssi.gouv.fr>
Date: Fri, 20 Sep 2019 14:02:42 +0200
Subject: [PATCH 114/162] slub: Extend init_on_free to slab caches with constructors

This is the remaining non-upstream part of SLAB_SANITIZE, which was a
partial port, from Daniel Micay, of the feature from PaX without the
default fast mode based on passing SLAB_NO_SANITIZE in
performance-critical cases that are not particularly security sensitive.

Signed-off-by: Thibaut Sautereau <thibaut.sautereau@ssi.gouv.fr>
[levente@leventepolyak.net: Adapt to kasan init_on_free with HW_TAGS changes]
Signed-off-by: Levente Polyak <levente@leventepolyak.net>
---
 mm/slab.h | 12 +++++++++---
 mm/slub.c | 18 ++++++++++++++++++
 2 files changed, 27 insertions(+), 3 deletions(-)

diff --git a/mm/slab.h b/mm/slab.h
index bf9d8940b8f2..fd91cfd0cf8e 100644
--- a/mm/slab.h
+++ b/mm/slab.h
@@ -636,8 +636,14 @@ static inline bool slab_want_init_on_free(struct kmem_cache *c)
 {
 	if (static_branch_maybe(CONFIG_INIT_ON_FREE_DEFAULT_ON,
-				&init_on_free))
-		return !(c->ctor ||
-			 (c->flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)));
+				&init_on_free)) {
+#ifndef CONFIG_SLUB
+		if (c->ctor)
+			return false;
+#endif
+		if (c->flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON))
+			return false;
+		return true;
+	}
 	return false;
 }

diff --git a/mm/slub.c b/mm/slub.c
index 67cb995a8562..bdb56196a228 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -2588,6 +2588,8 @@ bool slab_free_hook(struct kmem_cache *s, void *x, bool init,
 		set_orig_size(s, x, orig_size);

-	}
+		if (!IS_ENABLED(CONFIG_SLAB_SANITIZE_VERIFY) && s->ctor)
+			s->ctor(x);
+	}

 	if (canary) {
 		set_canary(s, x, s->random_inactive);
@@ -2637,7 +2639,23 @@ bool slab_free_freelist_hook(struct kmem_cache *s, void **head, void **tail,
 			 */
 			--(*cnt);
+
+			/* Objects that are put into quarantine by KASAN will
+			 * still undergo free_consistency_checks(), which
+			 * checks whether the freelist pointer is valid if it
+			 * is located after the object (see check_object()).
+			 * Since this is the case for slab caches with
+			 * constructors, we need to fix the freelist pointer
+			 * after init_on_free has overwritten it.
+			 *
+			 * Note that doing this for all caches (not just ctor
+			 * ones) would cause a GPF due to KASAN poisoning and
+			 * the way set_freepointer() eventually dereferences
+			 * the freepointer.
+			 */
+			if (slab_want_init_on_free(s) && s->ctor)
+				set_freepointer(s, object, NULL);
 		}
 	} while (object != old_tail);

 	return *head != NULL;
 }
--
2.52.0

