From b99022cdb217528675045c15b204dbcf72b97b45 Mon Sep 17 00:00:00 2001
From: Nicolas Bouchinet <nicolas.bouchinet@ssi.gouv.fr>
Date: Tue, 14 Oct 2025 15:19:31 +0200
Subject: [PATCH 121/184] mm/slub: Only instrument slab allocation with canaries

With barn and sheaves introduction, slab objects are used to prefill or
refill sheaves, which are cache of small objects taking the form of an
array of pointers to slab objects.

Sheaves are then used for quick allocation and free, which consist of
shrinking and growing the array index.
Thus, there is two vision of allocation state for those objects. While
they are seen as allocated by the slab allocator, the sheaf allocator
see them as free and then allocates them.

We thus need to adapt the slab canary patch in order to avoid sanitizing
objects allocation and free from this array.

A next patch will add a per-sheave canary random value which would lead
to a better tracking of objects overflow.

Signed-off-by: Levente Polyak <levente@leventepolyak.net>
Signed-off-by: Nicolas Bouchinet <nicolas.bouchinet@ssi.gouv.fr>
---
 mm/slub.c | 93 +++++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 69 insertions(+), 24 deletions(-)

diff --git a/mm/slub.c b/mm/slub.c
index f363333b22cf..2b58345ef695 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -919,10 +919,21 @@ static inline void set_canary(struct kmem_cache *s, void *object, unsigned long
 static inline void check_canary(struct kmem_cache *s, void *object, unsigned long value)
 {
 	unsigned long *canary = get_canary(s, object);
 	BUG_ON(*canary != get_canary_value(canary, value));
 }
+
+static inline void check_set_canary_bulk(struct kmem_cache *s, unsigned int size, void **objects, unsigned long check_value, unsigned long set_value)
+{
+	for (int i = 0; i < size; i++) {
+		if (!is_kfence_address(objects[i])) {
+			check_canary(s, objects[i], check_value);
+			set_canary(s, objects[i], set_value);
+		}
+	}
+}
+
 #else
 #define set_canary(s, object, value)
 #define check_canary(s, object, value)
 #endif
 
@@ -2777,10 +2788,11 @@ static bool sheaf_flush_main(struct kmem_cache *s)
 
 	remaining = sheaf->size;
 
 	local_unlock(&s->cpu_sheaves->lock);
 
+	check_set_canary_bulk(s, batch, &objects[0], s->random_active, s->random_inactive);
 	__kmem_cache_free_bulk(s, batch, &objects[0]);
 
 	stat_add(s, SHEAF_FLUSH, batch);
 
 	ret = true;
@@ -2795,22 +2807,46 @@ static bool sheaf_flush_main(struct kmem_cache *s)
  * Free all objects from a sheaf that's unused, i.e. not linked to any
  * cpu_sheaves, so we need no locking and batching. The locking is also not
  * necessary when flushing cpu's sheaves (both spare and main) during cpu
  * hotremove as the cpu is not executing anymore.
  */
-static void sheaf_flush_unused(struct kmem_cache *s, struct slab_sheaf *sheaf)
+static void sheaf_flush_unused(struct kmem_cache *s, struct slab_sheaf *sheaf, bool canary)
 {
 	if (!sheaf->size)
 		return;
 
 	stat_add(s, SHEAF_FLUSH, sheaf->size);
 
+	if (canary)
+		check_set_canary_bulk(s, sheaf->size, &sheaf->objects[0], s->random_active, s->random_inactive);
 	__kmem_cache_free_bulk(s, sheaf->size, &sheaf->objects[0]);
 
 	sheaf->size = 0;
 }
 
+static void __rcu_free_sheaf_prepare_nocanary(struct kmem_cache *s,
+				     struct slab_sheaf *sheaf)
+{
+	bool init = slab_want_init_on_free(s);
+	void **p = &sheaf->objects[0];
+	unsigned int i = 0;
+
+	while (i < sheaf->size) {
+		struct slab *slab = virt_to_slab(p[i]);
+
+		memcg_slab_free_hook(s, slab, p + i, 1);
+		alloc_tagging_slab_free_hook(s, slab, p + i, 1);
+
+		if (unlikely(!slab_free_hook(s, p[i], init, true, false))) {
+			p[i] = p[--sheaf->size];
+			continue;
+		}
+
+		i++;
+	}
+}
+
 static void __rcu_free_sheaf_prepare(struct kmem_cache *s,
 				     struct slab_sheaf *sheaf)
 {
 	bool init = slab_want_init_on_free(s);
 	void **p = &sheaf->objects[0];
@@ -2820,11 +2856,11 @@ static void __rcu_free_sheaf_prepare(struct kmem_cache *s,
 		struct slab *slab = virt_to_slab(p[i]);
 
 		memcg_slab_free_hook(s, slab, p + i, 1);
 		alloc_tagging_slab_free_hook(s, slab, p + i, 1);
 
-		if (unlikely(!slab_free_hook(s, p[i], init, true))) {
+		if (unlikely(!slab_free_hook(s, p[i], init, true, true))) {
 			p[i] = p[--sheaf->size];
 			continue;
 		}
 
 		i++;
@@ -2839,11 +2875,11 @@ static void rcu_free_sheaf_nobarn(struct rcu_head *head)
 	sheaf = container_of(head, struct slab_sheaf, rcu_head);
 	s = sheaf->cache;
 
 	__rcu_free_sheaf_prepare(s, sheaf);
 
-	sheaf_flush_unused(s, sheaf);
+	sheaf_flush_unused(s, sheaf, false);
 
 	free_empty_sheaf(s, sheaf);
 }
 
 /*
@@ -2870,11 +2906,11 @@ static void pcs_flush_all(struct kmem_cache *s)
 	pcs->rcu_free = NULL;
 
 	local_unlock(&s->cpu_sheaves->lock);
 
 	if (spare) {
-		sheaf_flush_unused(s, spare);
+		sheaf_flush_unused(s, spare, true);
 		free_empty_sheaf(s, spare);
 	}
 
 	if (rcu_free)
 		call_rcu(&rcu_free->rcu_head, rcu_free_sheaf_nobarn);
@@ -2887,13 +2923,13 @@ static void __pcs_flush_all_cpu(struct kmem_cache *s, unsigned int cpu)
 	struct slub_percpu_sheaves *pcs;
 
 	pcs = per_cpu_ptr(s->cpu_sheaves, cpu);
 
 	/* The cpu is not executing anymore so we don't need pcs->lock */
-	sheaf_flush_unused(s, pcs->main);
+	sheaf_flush_unused(s, pcs->main, true);
 	if (pcs->spare) {
-		sheaf_flush_unused(s, pcs->spare);
+		sheaf_flush_unused(s, pcs->spare, true);
 		free_empty_sheaf(s, pcs->spare);
 		pcs->spare = NULL;
 	}
 
 	if (pcs->rcu_free) {
@@ -3107,11 +3143,11 @@ static void barn_shrink(struct kmem_cache *s, struct node_barn *barn)
 	barn->nr_empty = 0;
 
 	spin_unlock_irqrestore(&barn->lock, flags);
 
 	list_for_each_entry_safe(sheaf, sheaf2, &full_list, barn_list) {
-		sheaf_flush_unused(s, sheaf);
+		sheaf_flush_unused(s, sheaf, true);
 		free_empty_sheaf(s, sheaf);
 	}
 
 	list_for_each_entry_safe(sheaf, sheaf2, &empty_list, barn_list)
 		free_empty_sheaf(s, sheaf);
@@ -5341,21 +5377,25 @@ unsigned int alloc_from_pcs_bulk(struct kmem_cache *s, size_t size, void **p)
 static __fastpath_inline void *slab_alloc_node(struct kmem_cache *s, struct list_lru *lru,
 		gfp_t gfpflags, int node, unsigned long addr, size_t orig_size)
 {
 	void *object;
 	bool init = false;
+	bool from_pcs = false;
 
 	s = slab_pre_alloc_hook(s, gfpflags);
 	if (unlikely(!s))
 		return NULL;
 
 	object = kfence_alloc(s, orig_size, gfpflags);
 	if (unlikely(object))
 		goto out;
 
-	if (s->cpu_sheaves)
+	if (s->cpu_sheaves) {
 		object = alloc_from_pcs(s, gfpflags, node);
+		if (object)
+			from_pcs = true;
+	}
 
 	if (!object)
 		object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);
 
 	maybe_wipe_obj_freeptr(s, object);
@@ -5371,11 +5411,11 @@ static __fastpath_inline void *slab_alloc_node(struct kmem_cache *s, struct list
 		kasan_poison_new_object(s, object);
 	} else {
 		init = slab_want_init_on_alloc(gfpflags, s);
 	}
 
-	if (object) {
+	if (object && !from_pcs) {
 		check_canary(s, object, s->random_inactive);
 		set_canary(s, object, s->random_active);
 	}
 
 out:
@@ -5515,11 +5555,11 @@ kmem_cache_prefill_sheaf(struct kmem_cache *s, gfp_t gfp, unsigned int size)
 	if (!sheaf)
 		sheaf = alloc_empty_sheaf(s, gfp);
 
 	if (sheaf && sheaf->size < size) {
 		if (refill_sheaf(s, sheaf, gfp)) {
-			sheaf_flush_unused(s, sheaf);
+			sheaf_flush_unused(s, sheaf, true);
 			free_empty_sheaf(s, sheaf);
 			sheaf = NULL;
 		}
 	}
 
@@ -5544,11 +5584,11 @@ void kmem_cache_return_sheaf(struct kmem_cache *s, gfp_t gfp,
 {
 	struct slub_percpu_sheaves *pcs;
 	struct node_barn *barn;
 
 	if (unlikely(sheaf->capacity != s->sheaf_capacity)) {
-		sheaf_flush_unused(s, sheaf);
+		sheaf_flush_unused(s, sheaf, true);
 		kfree(sheaf);
 		return;
 	}
 
 	local_lock(&s->cpu_sheaves->lock);
@@ -5572,11 +5612,11 @@ void kmem_cache_return_sheaf(struct kmem_cache *s, gfp_t gfp,
 	 * If the barn has too many full sheaves or we fail to refill the sheaf,
 	 * simply flush and free it.
 	 */
 	if (!barn || data_race(barn->nr_full) >= MAX_FULL_SHEAVES ||
 	    refill_sheaf(s, sheaf, gfp)) {
-		sheaf_flush_unused(s, sheaf);
+		sheaf_flush_unused(s, sheaf, true);
 		free_empty_sheaf(s, sheaf);
 		return;
 	}
 
 	barn_put_full_sheaf(barn, sheaf);
@@ -6182,11 +6222,11 @@ __pcs_replace_full_main(struct kmem_cache *s, struct slub_percpu_sheaves *pcs)
 		stat(s, BARN_PUT_FAIL);
 
 		pcs->spare = NULL;
 		local_unlock(&s->cpu_sheaves->lock);
 
-		sheaf_flush_unused(s, to_flush);
+		sheaf_flush_unused(s, to_flush, true);
 		empty = to_flush;
 		goto got_empty;
 	}
 
 	/*
@@ -6284,11 +6324,11 @@ static void rcu_free_sheaf(struct rcu_head *head)
 	 * to handle it as full (unless it became completely empty), as the code
 	 * handles it fine. The only downside is that sheaf will serve fewer
 	 * allocations when reused. It only happens due to debugging, which is a
 	 * performance hit anyway.
 	 */
-	__rcu_free_sheaf_prepare(s, sheaf);
+	__rcu_free_sheaf_prepare_nocanary(s, sheaf);
 
 	n = get_node(s, sheaf->node);
 	if (!n)
 		goto flush;
 
@@ -6310,11 +6350,11 @@ static void rcu_free_sheaf(struct rcu_head *head)
 		return;
 	}
 
 flush:
 	stat(s, BARN_PUT_FAIL);
-	sheaf_flush_unused(s, sheaf);
+	sheaf_flush_unused(s, sheaf, true);
 
 empty:
 	if (barn && data_race(barn->nr_empty) < MAX_EMPTY_SHEAVES) {
 		barn_put_empty_sheaf(barn, sheaf);
 		return;
@@ -6432,11 +6472,11 @@ static void free_to_pcs_bulk(struct kmem_cache *s, size_t size, void **p)
 		struct slab *slab = virt_to_slab(p[i]);
 
 		memcg_slab_free_hook(s, slab, p + i, 1);
 		alloc_tagging_slab_free_hook(s, slab, p + i, 1);
 
-		if (unlikely(!slab_free_hook(s, p[i], init, false))) {
+		if (unlikely(!slab_free_hook(s, p[i], init, false, false))) {
 			p[i] = p[--size];
 			continue;
 		}
 
 		if (unlikely(IS_ENABLED(CONFIG_NUMA) && slab_nid(slab) != node)) {
@@ -6518,14 +6558,16 @@ static void free_to_pcs_bulk(struct kmem_cache *s, size_t size, void **p)
 	/*
 	 * if we depleted all empty sheaves in the barn or there are too
 	 * many full sheaves, free the rest to slab pages
 	 */
 fallback:
+	check_set_canary_bulk(s, size, p, s->random_active, s->random_inactive);
 	__kmem_cache_free_bulk(s, size, p);
 
 flush_remote:
 	if (remote_nr) {
+		check_set_canary_bulk(s, remote_nr, &remote_objects[0], s->random_active, s->random_inactive);
 		__kmem_cache_free_bulk(s, remote_nr, &remote_objects[0]);
 		if (i < size) {
 			remote_nr = 0;
 			goto next_remote_batch;
 		}
@@ -6745,10 +6787,16 @@ void slab_free(struct kmem_cache *s, struct slab *slab, void *object,
 
 	/* Make sure canaries are not used on kfence objects. */
 	if (is_kfence_address(object))
 		canary = false;
 
+	/* Do not check or set canary if the object is freed back to pcs. */
+	if (s->cpu_sheaves && likely(!IS_ENABLED(CONFIG_NUMA) ||
+				     slab_nid(slab) == numa_mem_id())) {
+		canary = false;
+	}
+
 	if (unlikely(!slab_free_hook(s, object, slab_want_init_on_free(s), false, canary)))
 		return;
 
 	if (s->cpu_sheaves && likely(!IS_ENABLED(CONFIG_NUMA) ||
 				     slab_nid(slab) == numa_mem_id())) {
@@ -7491,11 +7539,11 @@ static inline
 int __kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,
 			    void **p)
 {
 	struct kmem_cache_cpu *c;
 	unsigned long irqflags;
-	int i, k;
+	int i;
 
 	/*
 	 * Drain objects in the per cpu slab, while disabling local
 	 * IRQs, which protects against PREEMPT and interrupts
 	 * handlers invoking normal fastpath.
@@ -7562,16 +7610,11 @@ int __kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,
 				s->ctor(p[j]);
 			kasan_poison_new_object(s, p[j]);
 		}
 	}
 
-	for (k = 0; k < i; k++) {
-		if (!is_kfence_address(p[k])) {
-			check_canary(s, p[k], s->random_inactive);
-			set_canary(s, p[k], s->random_active);
-		}
-	}
+	check_set_canary_bulk(s, i, p, s->random_inactive, s->random_active);
 
 	return i;
 
 error:
 	slub_put_cpu_ptr(s->cpu_slab);
@@ -7630,12 +7673,14 @@ int kmem_cache_alloc_bulk_noprof(struct kmem_cache *s, gfp_t flags, size_t size,
 		/*
 		 * If we ran out of memory, don't bother with freeing back to
 		 * the percpu sheaves, we have bigger problems.
 		 */
 		if (unlikely(__kmem_cache_alloc_bulk(s, flags, size - i, p + i) == 0)) {
-			if (i > 0)
+			if (i > 0) {
+				check_set_canary_bulk(s, i, p, s->random_active, s->random_inactive);
 				__kmem_cache_free_bulk(s, i, p);
+			}
 			return 0;
 		}
 	}
 
 	/*
-- 
2.52.0

